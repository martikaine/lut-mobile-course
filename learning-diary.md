## Exercise 1

I started following along the tutorial but quickly realized that it was quite out of date. Since I wanted to learn in a slightly more future-proof manner I decided to write the app in Kotlin (now the default for new Android Studio projects) and Jetpack Compose for creating the UI. There was definitely a steeper initial learning curve and some additional Googling at the start, but I much preferred the Jetpack Compose way of creating the UI over the old way shown in the video. The main ideas of composition and state management reminded me quite a lot of React, which I'm already pretty well versed in.

In Jetpack Compose, instead of defining an XML layout and then hooking into the components in code with `findViewById()`, the components are defined as Kotlin functions with an `@Composable` annotation, which a compiler plugin transforms to Android UI elements. A composable function may define some component-level logic, and ends with a tree of composables that should be rendered upon calling the function. Components can store mutable state variables with the `remember` helper function (very reminiscent of React's `useState()`), and when a state variable updates, the subtree of components using that state variable refreshes. In this example application, the state holding the values of the two `NumberTextField`s had to be hoisted upwards into their first common ancestor component `Calculator`, so that they could be added together.
